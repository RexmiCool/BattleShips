@page "/game"
@inject HttpClient Http
@inject GameState GameState

<h3>BattleShip Game</h3>

@if (!gameStarted)
{
    <div class="setup-container">
        <h4>Choisir la difficulté et la taille de la grille :</h4>
        <div class="form-group">
            <label for="difficulty">Difficulté :</label>
            <select class="styled-select" @bind="selectedDifficulty">
                <option value="1">Facile</option>
                <option value="2">Moyen</option>
                <option value="3">Difficile</option>
            </select>
        </div>

        <div class="form-group">
            <label for="gridSize">Taille de la grille :</label>
            <select class="styled-select" @bind="selectedGridSize">
                <option value="8">8x8</option>
                <option value="10">10x10</option>
                <option value="12">12x12</option>
            </select>
        </div>

        <div class="form-group">
            <input type="checkbox" @bind="manualPlacement" /> Placer manuellement les navires
        </div>

        @if (manualPlacement)
        {
            <div class="form-group">
                <label for="orientation">Orientation :</label>
                <select class="styled-select" @bind="selectedOrientation">
                    <option value="horizontal">Horizontal</option>
                    <option value="vertical">Vertical</option>
                </select>
            </div>
                
            <div class="form-group">
                <label for="shipSelect">Sélectionner un navire à placer :</label>
                <select class="styled-select" @bind="selectedShip">
                    @foreach (var ship in availableShips)
                    {
                        <option value="@ship.Key">@ship.Key (taille: @ship.Value)</option>
                    }
                </select>
            </div>


            <div class="grid-container">
                <h4>Placez vos navires</h4>
                <table>
                    @for (int row = 0; row < selectedGridSize; row++)
                    {
                        <tr>
                            @for (int col = 0; col < selectedGridSize; col++)
                            {
                                var currentRow = row;
                                var currentCol = col;
                                <td class="placement-cell @(GameState.PlayerGrid[currentRow, currentCol] != '\0' ? "ship" : "")"
                                    @onclick="() => PlaceShipPart(currentRow, currentCol)">
                                    @if (GameState.PlayerGrid[currentRow, currentCol] != '\0')
                                    {
                                        <span>@GameState.PlayerGrid[currentRow, currentCol]</span>
                                    }
                                </td>
                            }
                        </tr>
                    }
                </table>
            </div>
        }

        <button class="start-button" @onclick="() => StartNewGame(selectedDifficulty, selectedGridSize)" disabled="@(manualPlacement && placedShips.Count < 6)">
            Démarrer une nouvelle partie
        </button>
    </div>
}
else
{
    <button class="restart-button" @onclick="RestartGame">Redémarrer la partie</button>
    @if (!string.IsNullOrEmpty(GameState.Message))
    {
        <div class="alert alert-success">@GameState.Message</div>
    }

    <div class="board-container">

        <div>
            <h3>Leaderboard</h3>

            @if (GameState.leaderboard != null)
            {
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Joueur</th>
                            <th>Parties Gagnées</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var entry in GameState.leaderboard)
                        {
                            <tr>
                                <td>@entry.Key</td>
                                <td>@entry.Value</td>
                            </tr>
                        }
                    </tbody>
                </table>
            }
        </div>

        <div class="grid-container">
            <h4>Grille du Joueur</h4>
            <table>
                @for (int row = 0; row < GameState.PlayerGrid.GetLength(0); row++)
                {
                    <tr>
                        @for (int col = 0; col < GameState.PlayerGrid.GetLength(1); col++)
                        {
                            <td class="@(IsBoatPart(GameState.PlayerGrid[row, col]) ? "bateau" : "")">
                                @if (IsBoatPart(GameState.DefaultPlayerGrid[row, col]))
                                {
                                    if(GameState.DefaultPlayerGrid[row, col]=='A'){
                                        <img src="images/boat_A.png" 
                                        alt="Bateau A" />
                                    }
                                    else{
                                        var boatType = GameState.DefaultPlayerGrid[row, col];  // Le type de bateau (A, B, C...)
                                        var orientation = GetBoatOrientation(row, col); // Méthode pour déterminer l'orientation du bateau
                                        var partType = GetBoatPartType(row, col); // Méthode pour déterminer si c'est l'avant, le milieu, ou l'arrière

                                        // Sélectionner l'image en fonction de la position et de l'orientation
                                        <img src="images/boat_@(partType)_@(orientation).png" 
                                            alt="Bateau @(boatType) @(partType) @(orientation)" />
                                    }
                                }

                                @if (GameState.PlayerGrid[row, col] == 'X')
                                {
                                    <img src="images/hit.png" alt="Touché" />
                                }
                                else if (GameState.PlayerGrid[row, col] == 'O')
                                {
                                    <img src="images/miss_splash.png" alt="Raté" />
                                }
                                else
                                {
                                    <span> </span>  // Case vide
                                }
                            </td>
                        }
                    </tr>
                }
            </table>
        </div>

        <div class="history-container">
            <h4>Historique</h4>
            @if (history != null)
            {
                <ul>
                    @foreach (var move in history)
                    {
                        <li>@move</li>
                    }
                </ul>
            }
            else
            {
                <p>Aucun historique disponible.</p>
            }

            <button class="undo-button" @onclick="UndoMove" disabled="@(history == null || history.Count == 0)">
                Retour arrière
            </button>
        </div>

        <div class="grid-container">
            <h4>Grille de l'Adversaire</h4>
            <table>
                @for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    <tr>
                        @for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                        {
                            var currentRow = row;
                            var currentCol = col;
                            <td class="@(GameState.OpponentGrid[currentRow, currentCol] == true ? "hit" : "")">
                                @if (GameState.OpponentGrid[currentRow, currentCol] == true)
                                {
                                    <img src="images/hit.png" alt="Touché" />
                                }
                                else if (GameState.OpponentGrid[currentRow, currentCol] == false)
                                {
                                    <img src="images/miss_splash.png" alt="Raté" />
                                }
                                else
                                {
                                    <button class="invisible-button" @onclick="() => PlayMove(GameState.GameId, currentRow, currentCol)" disabled="@GameState.GameFinished">?</button>
                                }
                            </td>
                        }
                    </tr>
                }
            </table>
        </div>
    </div>

    @if (GameState.GameFinished == true)
    {
        <div class="overlay">
            <div class="popup">
                <h2>@(GameState.Message)</h2>
                <button @onclick="RestartGame">Rejouer</button>
            </div>
        </div>
    }

}

@code {
    [Parameter]
    [SupplyParameterFromQuery(Name = "userName")]
    public string userName { get; set; }


    private bool gameStarted = false;
    private int selectedDifficulty;
    private int selectedGridSize;

    private bool manualPlacement = false;
    private string selectedOrientation = "horizontal";
    // Grille de placement des navires
    private int selectedShipSize = 3;
    private Dictionary<char, int> availableShips = new Dictionary<char, int>()
    {
        { 'A', 1 }, { 'B', 2 }, { 'C', 2 }, { 'D', 3 }, { 'E', 3 }, { 'F', 4 }
    };
    private char? selectedShip = null;
    private Dictionary<char, List<List<int>>> placedShips = new();


    protected override void OnParametersSet()
    {
        GameState.Initialize(selectedGridSize, selectedDifficulty);
    }

    // private void InitializePlayerShipGrid()
    // {
    //     Si la grille n'est pas initialisée ou si la taille a changé, la réinitialiser
    //     if (GameState.PlayerGrid == null || GameState.PlayerGrid.GetLength(0) != selectedGridSize)
    //     {
    //         GameState.PlayerGrid = new char[selectedGridSize, selectedGridSize];
    //     }
    // }

    private void PlaceShipPart(int row, int col)
    {
        if (selectedShip.HasValue && !placedShips.ContainsKey(selectedShip.Value))
        {
            var shipSize = availableShips[selectedShip.Value];
            var coordinates = new List<List<int>>();
            // Vérifier si le navire peut être placé sans sortir des limites et sans chevaucher
            if (CanPlaceShip(row, col, shipSize, selectedOrientation))
            {
                // Placer le navire sur la grille
                for (int i = 0; i < shipSize; i++)
                {
                    if (selectedOrientation == "horizontal") {
                        GameState.PlayerGrid[row, col + i] = selectedShip.Value;
                        coordinates.Add(new List<int> { row, col + i});
                    }
                    else
                    {
                        GameState.PlayerGrid[row + i, col] = selectedShip.Value;
                        coordinates.Add(new List<int> { row + i, col });
                    }
                }
                placedShips[selectedShip.Value] = coordinates;
            }
        }
    }

    private bool CanPlaceShip(int row, int col, int size, string orientation)
    {
        // Vérifier si le navire reste dans les limites et ne chevauche pas
        for (int i = 0; i < size; i++)
        {
            if (orientation == "horizontal" && (col + i >= selectedGridSize || GameState.PlayerGrid[row, col + i] != '\0'))
                return false;
            if (orientation == "vertical" && (row + i >= selectedGridSize || GameState.PlayerGrid[row + i, col] != '\0'))
                return false;
        }
        return true;
    }


    // Méthode pour démarrer une nouvelle partie
    private async Task StartNewGame(int difficulty, int gridSize)
    {
        var request = new RestartGameRequest
            {
                difficulty = difficulty,
                gridSize = gridSize,
                playerOne = userName,
                multi = false,
                playerOneBoatPositions = (placedShips.Keys.Count>0)?placedShips:null
            };
        var response = await Http.PostAsJsonAsync("game/new", request);

        if (response.IsSuccessStatusCode)
        {
            var gameResponse = await response.Content.ReadFromJsonAsync<GameResponse>();

            if (gameResponse != null)
            {
                gameStarted = true;

                GameState.GameId = gameResponse.gameId;

                GameState.boatLocations = gameResponse.boatLocations;

                GameState.Initialize(selectedGridSize, selectedDifficulty);

                // Placement automatique des navires
                foreach (var boat in GameState.boatLocations)
                {
                    foreach (var part in boat.Value)
                    {
                        int row = part[0];
                        int col = part[1];
                        GameState.PlayerGrid[row, col] = boat.Key;  // Utilise le caractère du bateau
                        GameState.DefaultPlayerGrid[row, col] = boat.Key;
                    }
                }

                // Réinitialiser la grille de l'adversaire
                for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                    {
                        GameState.OpponentGrid[row, col] = null;
                    }
                }
            }
        }
        else
        {
            GameState.Message = "Erreur lors de la création de la partie.";
        }
    }

    private async Task PlayMove(int gameId, int row, int col)
    {
        var attackRequest = new AttackRequest(gameId, row, col);
        var response = await Http.PostAsJsonAsync("/game/attack", attackRequest);

        // Lire le contenu brut de la réponse pour le débogage
        var rawContent = await response.Content.ReadAsStringAsync();
        Console.WriteLine($"Raw response: {rawContent}");  // Affichez le contenu brut dans la console

        if (response.IsSuccessStatusCode)
        {
            var attackResponse = await response.Content.ReadFromJsonAsync<AttackResponse>();

            // Mettez à jour la grille de l'adversaire
            GameState.OpponentGrid[row, col] = attackResponse.playerAttack == 1;
            await LoadHistory();

            if (attackResponse.winner.HasValue && attackResponse.winner.Value == 1)
            {
                GameState.Message = "Vous avez gagné !";
                GameState.GameFinished = true;  // Marque la fin de la partie
                return;
            }

            // Mettez à jour la grille du joueur avec les résultats de l'attaque IA
            var botCoordinates = attackResponse.botAttackCoordinates;
            if (botCoordinates.row >= 0 && botCoordinates.column >= 0 && botCoordinates.row < GameState.GridSize && botCoordinates.column < GameState.GridSize)
            {
                GameState.PlayerGrid[botCoordinates.row, botCoordinates.column] = attackResponse.botAttack == 1 ? 'X' : 'O';
            }
            await LoadHistory();

            if (attackResponse.winner.HasValue && attackResponse.winner.Value == 2 )
            {
                GameState.Message = "Vous avez perdu...";
                GameState.GameFinished = true;
                return;
            }
        }
        else
        {
            GameState.Message = "Erreur lors de la requête à l'API.";
        }
    }

    private async Task RestartGame()
    {
        var request = new RestartGameRequest
            {
                gameId = GameState.GameId,
                difficulty = GameState.Difficulty,
                gridSize = GameState.GridSize,
                multi = false, 
                playerOne = userName
            };

        var response = await Http.PostAsJsonAsync("game/restart", request);

        if (response.IsSuccessStatusCode)
        {
            var gameResponse = await response.Content.ReadFromJsonAsync<GameResponse>();

            if (gameResponse != null)
            {
                GameState.GameId = gameResponse.gameId;
                GameState.GameFinished = false;
                GameState.boatLocations = gameResponse.boatLocations;
                await LoadHistory();
                await LoadLeaderboard();

                // Réinitialiser la grille du joueur
                for (int row = 0; row < GameState.PlayerGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.PlayerGrid.GetLength(1); col++)
                    {
                        GameState.PlayerGrid[row, col] = ' '; // Remettre à l'état vide, par exemple un espace
                        GameState.DefaultPlayerGrid[row, col] = ' '; // Remettre à l'état vide, par exemple un espace
                    }
                }

                // Réinitialiser la grille de l'adversaire
                for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                    {
                        GameState.OpponentGrid[row, col] = null; // Remettre à null
                    }
                }

                // Initialiser la grille du joueur avec les nouveaux bateaux
                foreach (var boat in gameResponse.boatLocations)
                {
                    foreach (var part in boat.Value)
                    {
                        int row = part[0];
                        int col = part[1];
                        GameState.PlayerGrid[row, col] = boat.Key;  // Utilise le caractère du bateau
                        GameState.DefaultPlayerGrid[row, col] = boat.Key;  // Utilise le caractère du bateau
                    }
                }

                GameState.Message = "Partie redémarrée avec succès.";
            }
        }
        else
        {
            GameState.Message = "Erreur lors du redémarrage de la partie.";
        }
    }

    private List<string> history;

    protected override async Task OnInitializedAsync()
    {
        await LoadHistory();
    }

    private async Task LoadHistory()
    {
        try
        {
            int gameId = GameState.GameId; // Utilise l'ID du jeu
            history = await Http.GetFromJsonAsync<List<string>>($"game/history?gameId={gameId}");
            StateHasChanged(); // Force la mise à jour de l'interface
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement de l'historique: {ex.Message}");
        }
    }

    private async Task UndoMove()
    {
        try
        {
            if (history != null && history.Count > 0)
            {
                var undoRequest = new UndoRequest(GameState.GameId, 1);

                var response = await Http.PostAsJsonAsync("/game/undo", undoRequest);

                var moves = await response.Content.ReadFromJsonAsync<List<Move>>();

                if (response.IsSuccessStatusCode)
                {
                    // Si succès, recharge l'historique et mets à jour les grilles
                    await LoadHistory();
                    foreach (var move in moves)
                    {
                        if (move.Player != userName)
                        {
                            if (move.Hit)
                            {
                                foreach (var boat in GameState.boatLocations)
                                {
                                    foreach (var part in boat.Value)
                                    {
                                        int row = part[0];
                                        int col = part[1];
                                        if(row == move.Row && col == move.Column)
                                        {
                                            GameState.PlayerGrid[move.Row, move.Column] = boat.Key;
                                            continue;
                                        }
                                    }
                                }
                            } else
                            {
                                GameState.PlayerGrid[move.Row, move.Column] = '\0';
                            }
                        }
                        else
                        {
                            GameState.OpponentGrid[move.Row, move.Column] = null;
                        }
                    }
                    StateHasChanged();
                    GameState.Message = "Dernier coup annulé avec succès.";
                }
                else
                {
                    GameState.Message = "Erreur lors de l'annulation du coup.";
                }
            }
        }
        catch (Exception ex)
        {
            GameState.Message = $"Erreur: {ex.Message}";
        }
    }

    private bool IsBoatPart(char cell)
    {
        return new[] { 'A', 'B', 'C', 'D', 'E', 'F' }.Contains(cell);
    }

    private string GetBoatOrientation(int row, int col)
    {
        // Vérification pour orientation verticale
        if (row + 1 < GameState.DefaultPlayerGrid.GetLength(0) && GameState.DefaultPlayerGrid[row, col] == GameState.DefaultPlayerGrid[row + 1, col])
        {
            return "vertical";
        }
        else if (row - 1 >= 0 && GameState.DefaultPlayerGrid[row, col] == GameState.DefaultPlayerGrid[row - 1, col])
        {
            return "vertical";
        }

        return "horizontal";  // Par défaut si ce n'est pas vertical
    }

    private string GetBoatPartType(int row, int col)
    {
        // Vérifier la position du bateau (avant, milieu, arrière)

        // Si la case précédente et suivante dans l'orientation sont libres ou différentes, c'est une extrémité.
        if (GetBoatOrientation(row, col) == "horizontal")
        {
            if (col - 1 < 0 || GameState.DefaultPlayerGrid[row, col - 1] != GameState.DefaultPlayerGrid[row, col])  // Avant
            {
                return "front"; //front
            }
            else if (col + 1 >= GameState.DefaultPlayerGrid.GetLength(1) || GameState.DefaultPlayerGrid[row, col + 1] != GameState.DefaultPlayerGrid[row, col])  // Arrière
            {
                return "back";
            }
        }
        else // Orientation verticale
        {
            if (row - 1 < 0 || GameState.DefaultPlayerGrid[row - 1, col] != GameState.DefaultPlayerGrid[row, col])  // Avant
            {
                return "front";
            }
            else if (row + 1 >= GameState.DefaultPlayerGrid.GetLength(0) || GameState.DefaultPlayerGrid[row + 1, col] != GameState.DefaultPlayerGrid[row, col])  // Arrière
            {
                return "back";
            }
        }

        return "middle";  // Sinon, c'est une partie du milieu
    }


    private async Task LoadLeaderboard()
    {
        try
        {
            var response = await Http.GetFromJsonAsync<Dictionary<string, int>>("/game/leaderboard");
            GameState.leaderboard = response ?? new Dictionary<string, int>();

            // Forcer la mise à jour de l'interface
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement du leaderboard : {ex.Message}");
        }
    }
}