@page "/game"
@inject HttpClient Http
@inject GameState GameState

<h3>BattleShip Game</h3>

@if (!gameStarted)
{
    <div class="setup-container">
        <h4>Choisir la difficulté et la taille de la grille :</h4>
        <div class="form-group">
            <label for="difficulty">Difficulté :</label>
            <select class="styled-select" @bind="selectedDifficulty">
                <option value="1">Facile</option>
                <option value="2">Moyen</option>
                <option value="3">Difficile</option>
            </select>
        </div>

        <div class="form-group">
            <label for="gridSize">Taille de la grille :</label>
            <select class="styled-select" @bind="selectedGridSize">
                <option value="8">8x8</option>
                <option value="10">10x10</option>
                <option value="12">12x12</option>
            </select>
        </div>

        <button class="start-button" @onclick="() => StartNewGame(selectedDifficulty, selectedGridSize)">
            Démarrer une nouvelle partie
        </button>
    </div>
}
else
{
    <button class="restart-button" @onclick="RestartGame">Redémarrer la partie</button>
    <div class="board-container">

        <div class="grid-container">
            <h4>Grille du Joueur</h4>
            <table>
                @for (int row = 0; row < GameState.PlayerGrid.GetLength(0); row++)
                {
                    <tr>
                        @for (int col = 0; col < GameState.PlayerGrid.GetLength(1); col++)
                        {
                            <td class="@(new[] { 'A', 'B', 'C', 'D', 'E', 'F' }.Contains(GameState.PlayerGrid[row, col])
                            ? "bateau"
                            : GameState.PlayerGrid[row, col] == 'X'
                                ? "hit"
                                : GameState.PlayerGrid[row, col] == 'O'
                                    ? "miss"
                                    : "")">
                                @if (GameState.PlayerGrid[row, col] == 'X')
                                {
                                    <img src="images/hit.png" alt="Touché" />
                                }
                                else if (GameState.PlayerGrid[row, col] == 'O')
                                {
                                    <img src="images/miss_splash.png" alt="Raté" />
                                }
                                else @if (GameState.PlayerGrid[row, col] != '\0')
                                {
                                    <span>@GameState.PlayerGrid[row, col]</span>
                                } else
                                {
                                    <span>~</span>
                                }
                            </td>
                        }
                    </tr>
                }
            </table>
        </div>

        <div class="history-container">
            <h4>Historique</h4>
            @if (history != null)
            {
                <ul>
                    @foreach (var move in history)
                    {
                        <li>@move</li>
                    }
                </ul>
            }
            else
            {
                <p>Aucun historique disponible.</p>
            }

            <button class="undo-button" @onclick="UndoMove" disabled="@(history == null || history.Count == 0)">
                Retour arrière
            </button>
        </div>

        <div class="grid-container">
            <h4>Grille de l'Adversaire</h4>
            <table>
                @for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    <tr>
                        @for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                        {
                            var currentRow = row;
                            var currentCol = col;
                            <td class="@(GameState.OpponentGrid[currentRow, currentCol] == true ? "hit" : GameState.OpponentGrid[currentRow, currentCol] == false ? "miss" : "")">
                                @if (GameState.OpponentGrid[currentRow, currentCol] == true)
                                {
                                    <img src="images/hit.png" alt="Touché" />
                                }
                                else if (GameState.OpponentGrid[currentRow, currentCol] == false)
                                {
                                    <img src="images/miss_splash.png" alt="Raté" />
                                }
                                else
                                {
                                    <button class="invisible-button" @onclick="() => PlayMove(GameState.GameId, currentRow, currentCol)" disabled="@GameState.GameFinished">?</button>
                                }
                            </td>
                        }
                    </tr>
                }
            </table>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(GameState.Message))
    {
        <div class="alert alert-success">@GameState.Message</div>
    }

    @if (GameState.GameFinished == true)
    {
        <div class="overlay">
            <div class="popup">
                <h2>@(GameState.Message)</h2>
                <button @onclick="RestartGame">Rejouer</button>
            </div>
        </div>
    }

}

@code {
    private bool gameStarted = false;
    private int selectedDifficulty = 1;
    private int selectedGridSize = 10;

    [Parameter]
    [SupplyParameterFromQuery(Name = "userName")]
    public string userName { get; set; }

    private async Task StartNewGame(int difficulty, int gridSize)
    {
        var request = new RestartGameRequest
            {
                difficulty = difficulty,
                gridSize = gridSize,
                playerOne = userName,
                multi = false
            };
        var response = await Http.PostAsJsonAsync("game/new", request);

        if (response.IsSuccessStatusCode)
        {
            var gameResponse = await response.Content.ReadFromJsonAsync<GameResponse>();

            if (gameResponse != null)
            {
                gameStarted = true;

                GameState.Initialize(gridSize);
                GameState.GameId = gameResponse.gameId;

                // Initialiser la grille du joueur avec les bateaux
                foreach (var boat in gameResponse.boatLocations)
                {
                    foreach (var part in boat.Value)
                    {
                        int row = part[0];
                        int col = part[1];
                        GameState.PlayerGrid[row, col] = boat.Key;  // Utilise le caractère du bateau
                    }
                }

                // Réinitialiser la grille de l'adversaire
                for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                    {
                        GameState.OpponentGrid[row, col] = null;
                    }
                }
            }
        }
        else
        {
            GameState.Message = "Erreur lors de la création de la partie.";
        }
    }

    private async Task PlayMove(int gameId, int row, int col)
    {
        var attackRequest = new AttackRequest(gameId, row, col);
        var response = await Http.PostAsJsonAsync("/game/attack", attackRequest);

        // Lire le contenu brut de la réponse pour le débogage
        var rawContent = await response.Content.ReadAsStringAsync();
        Console.WriteLine($"Raw response: {rawContent}");  // Affichez le contenu brut dans la console

        if (response.IsSuccessStatusCode)
        {
            var attackResponse = await response.Content.ReadFromJsonAsync<AttackResponse>();

            // Mettez à jour la grille de l'adversaire
            GameState.OpponentGrid[row, col] = attackResponse.playerAttack == 1;
            await LoadHistory();

            if (attackResponse.winner.HasValue && attackResponse.winner.Value == 1)
            {
                GameState.Message = "Vous avez gagné !";
                GameState.GameFinished = true;  // Marque la fin de la partie
                return;
            }

            // Mettez à jour la grille du joueur avec les résultats de l'attaque IA
            var botCoordinates = attackResponse.botAttackCoordinates;
            GameState.PlayerGrid[botCoordinates.row, botCoordinates.column] = attackResponse.botAttack == 1 ? 'X' : 'O';
            await LoadHistory();

            if (attackResponse.winner.HasValue && attackResponse.winner.Value == 0)
            {
                GameState.Message = "Vous avez perdu...";
                GameState.GameFinished = true;
                return;
            }
        }
        else
        {
            GameState.Message = "Erreur lors de la requête à l'API.";
        }
    }

    private async Task RestartGame()
    {
        var request = new RestartGameRequest
            {
                gameId = GameState.GameId,
                difficulty = selectedDifficulty,
                gridSize = selectedGridSize
            };

        var response = await Http.PostAsJsonAsync("game/restart", request);

        if (response.IsSuccessStatusCode)
        {
            var gameResponse = await response.Content.ReadFromJsonAsync<GameResponse>();

            if (gameResponse != null)
            {
                GameState.GameId = gameResponse.gameId;
                GameState.GameFinished = false;
                await LoadHistory();

                // Réinitialiser la grille du joueur
                for (int row = 0; row < GameState.PlayerGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.PlayerGrid.GetLength(1); col++)
                    {
                        GameState.PlayerGrid[row, col] = ' '; // Remettre à l'état vide, par exemple un espace
                    }
                }

                // Réinitialiser la grille de l'adversaire
                for (int row = 0; row < GameState.OpponentGrid.GetLength(0); row++)
                {
                    for (int col = 0; col < GameState.OpponentGrid.GetLength(1); col++)
                    {
                        GameState.OpponentGrid[row, col] = null; // Remettre à null
                    }
                }

                // Initialiser la grille du joueur avec les nouveaux bateaux
                foreach (var boat in gameResponse.boatLocations)
                {
                    foreach (var part in boat.Value)
                    {
                        int row = part[0];
                        int col = part[1];
                        GameState.PlayerGrid[row, col] = boat.Key;  // Utilise le caractère du bateau
                    }
                }

                GameState.Message = "Partie redémarrée avec succès.";
            }
        }
        else
        {
            GameState.Message = "Erreur lors du redémarrage de la partie.";
        }
    }

    private List<string> history;

    protected override async Task OnInitializedAsync()
    {
        await LoadHistory();
    }

    private async Task LoadHistory()
    {
        try
        {
            int gameId = GameState.GameId; // Utilise l'ID du jeu
            history = await Http.GetFromJsonAsync<List<string>>($"game/history?gameId={gameId}");
            StateHasChanged(); // Force la mise à jour de l'interface
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du chargement de l'historique: {ex.Message}");
        }
    }

    private async Task UndoMove()
    {
        try
        {
            if (history != null && history.Count > 0)
            {
                var undoRequest = new UndoRequest(GameState.GameId, 2);

                var response = await Http.PostAsJsonAsync("/game/undo", undoRequest);

                if (response.IsSuccessStatusCode)
                {
                    // Si succès, recharge l'historique et mets à jour les grilles
                    await LoadHistory();
                    GameState.Message = "Dernier coup annulé avec succès.";
                }
                else
                {
                    GameState.Message = "Erreur lors de l'annulation du coup.";
                }
            }
        }
        catch (Exception ex)
        {
            GameState.Message = $"Erreur: {ex.Message}";
        }
    }

}